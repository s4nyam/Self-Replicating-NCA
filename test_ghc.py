# -*- coding: utf-8 -*-
"""test GHC

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ip2bwoFXlQWp3vMIjri0ihxsVtvffice

# Test GHC
"""

# prompt: round those random values to 2 decial points

import numpy as np


# Define the shape of the array
shape = (10, 10, 10, 44)

# Create the array with random values between -1 and 1
random_array = 1.98 * np.random.rand(*shape) - 0.99

# Round the values to 2 decimal points
rounded_array = np.round(random_array, 2)

# print(rounded_array)

sample = np.array(rounded_array)
params = sample[0][0][0].shape[0]
sample = sample.reshape(10,10,10,params)
height, width = sample.shape[1]-1, sample.shape[2]-1
length_sim = sample.shape[0]

import random
import numpy as np
import matplotlib.pyplot as plt
import os
output_folder = "gd_ghc_frames_png"
output_folder2 = "gd_ghc_frames_pdf"

# Make sure the output folder exists
if not os.path.exists(output_folder):
    os.makedirs(output_folder)
if not os.path.exists(output_folder2):
    os.makedirs(output_folder2)
# sample[8][0] # weights of the NN at different time steps
# fig, ax = plt.subplots()

counts_per_frame = []
for i in range(length_sim):
  # Function to hash a 44-bit gene sequence to 24 bits using Python's built-in hash function
  def hash_gene_sequence(gene_sequence):
      return [int(hash(value) % 2) for value in gene_sequence]

  # Function to convert a 24-bit sequence to three 8-bit values
  def split_to_rgb(sequence):
      r = int(''.join(map(str, sequence[:8])), 2)
      g = int(''.join(map(str, sequence[8:16])), 2)
      b = int(''.join(map(str, sequence[16:24])), 2)
      return r, g, b

  # Create an empty grid to store the RGB values for each cell
  grid = np.zeros((height, width, 3), dtype=np.uint8)

  # Populate the grid with color-coded gene sequences
  for row in range(height):
      for col in range(width):
          gene_sequence = sample[i][row][col]
          gene_sequence = gene_sequence.tolist()
          hashed_sequence = hash_gene_sequence(gene_sequence)
          r, g, b = split_to_rgb(hashed_sequence)
          grid[row, col] = [r, g, b]
  frame_filename = os.path.join(output_folder2, f"{i + 1:07d}.pdf")
  fig = plt.figure()
  im = plt.imshow(grid,interpolation='none',cmap='jet')
  # Count unique RGB colors
  flattened_data = grid.reshape(-1, 3)
  print("flattened_data")
  print(flattened_data)
  unique_colors, counts = np.unique(flattened_data, axis=0, return_counts=True)
  print("unique_colors")
  print(unique_colors)
  unique_colors_count = len(unique_colors)
  # Store the count of unique RGB colors for this frame
  counts_per_frame.append(unique_colors_count)
  plt.title(f'Generation {i + 1}')
#   cax = fig.add_axes([0.08, 0.94, 0.15, 0.02])
#   colorbar = fig.colorbar(im, cax=cax, orientation='horizontal', shrink=0.7)
#   min_value = np.min(grid)
#   max_value = np.max(grid)
#   mid_value = (min_value + max_value) / 2
#   ticks = [min_value, (min_value + mid_value) / 2, mid_value, (mid_value + max_value) / 2, max_value]  # Include midpoints
#   rounded_ticks = [round(value) for value in ticks]
#   ticks = rounded_ticks
#   colorbar.set_ticks(ticks)
#   colorbar.ax.tick_params(axis='x', labelsize=6)
  # plt.axis('off')
  plt.savefig(frame_filename,format='pdf',dpi=600)
  frame_filename = os.path.join(output_folder, f"{i + 1:07d}.png")
  plt.savefig(frame_filename,format='png',dpi=600)
  plt.close()



"""# Test HASH Function"""

import random
perturbation_probability = 0.20
total_runs = 1000
def hash_gene_sequence(gene_sequence):
    return [int(hash(value) % 2) for value in gene_sequence]

def round_list(lst):
  return [round(x,2) for x in lst]

def generate_random44_data():
  genes_list = []
  for i in range(44):
    genes_list.append((2 * round(random.random(),2) - 1))
  genes_list = round_list(genes_list)
  return genes_list

def inherit_and_mutate(parent_list):
  # 20% perturbation
  perturbed_list = []
  for i in range(44):
    if(random.random()<perturbation_probability):
      perturbed_list.append(parent_list[i] + (2 * round(random.random(),2) - 1))
    else:
      perturbed_list.append(parent_list[i])
  perturbed_list = round_list(perturbed_list)
  return perturbed_list

def compare_lists(list1, list2):
    return "same" if list1 == list2 else "Not Same"

countersame = 0
counternotsame = 0
for i in range(total_runs):
  list1 = generate_random44_data()
  list2 = inherit_and_mutate(list1)
  hl1 = hash_gene_sequence(list1)
  hl2 = hash_gene_sequence(list2)
  if(compare_lists(hl1,hl2) == 'same'):
    countersame = countersame + 1
  else:
    counternotsame = counternotsame + 1

print("Same: ", countersame)
print("Not Same: ", counternotsame)

"""# Larger Experiments for GHC Test"""

import random
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

def hash_gene_sequence(gene_sequence):
    return [int(hash(value) % 2) for value in gene_sequence]

def round_list(lst):
    return [round(x, 2) for x in lst]

def generate_random44_data():
    genes_list = []
    for i in range(44):
        genes_list.append((2 * round(random.random(), 2) - 1))
    genes_list = round_list(genes_list)
    return genes_list

def inherit_and_mutate(parent_list, perturbation_probability):
    perturbed_list = []
    for i in range(44):
        if random.random() < perturbation_probability:
            perturbed_list.append(parent_list[i] + (2 * round(random.random(), 2) - 1))
        else:
            perturbed_list.append(parent_list[i])
    perturbed_list = round_list(perturbed_list)
    return perturbed_list

def compare_lists(list1, list2):
    return "same" if list1 == list2 else "Not Same"

# Parameters
perturbation_probabilities = np.arange(0.1, 0.9, 0.1)  # Example: [0.1, 0.2, 0.3, 0.4, 0.5]
total_runs_list = [500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000]  # Example: [500, 1000, 1500, 2000]
# perturbation_probabilities = np.arange(0.1, 0.6, 0.1)  # Example: [0.1, 0.2, 0.3, 0.4, 0.5]
# total_runs_list = [500, 1000, 1500, 2000]  # Example: [500, 1000, 1500, 2000]

# Collect data for the plot
data = []

for perturbation_probability in perturbation_probabilities:
    for total_runs in total_runs_list:
        countersame = 0
        for i in range(total_runs):
            list1 = generate_random44_data()
            list2 = inherit_and_mutate(list1, perturbation_probability)
            hl1 = hash_gene_sequence(list1)
            hl2 = hash_gene_sequence(list2)
            if compare_lists(hl1, hl2) == 'same':
                countersame += 1
        data.append((total_runs, perturbation_probability, countersame))

# Prepare data for plotting
total_runs, perturbation_probabilities, collisions = zip(*data)

# Convert to numpy arrays for easier handling
total_runs = np.array(total_runs)
perturbation_probabilities = np.array(perturbation_probabilities)
collisions = np.array(collisions)

# Plotting the results
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Scatter plot
sc = ax.scatter(total_runs, perturbation_probabilities, collisions, c=collisions, cmap='viridis', marker='o', s=10)
fig.colorbar(sc, ax=ax, label='Number of Collisions')

# Labels
ax.set_xlabel('Total Runs')
ax.set_ylabel('Perturbation Probability')
ax.set_zlabel('Collisions')

# Set perspective for better readability
ax.view_init(elev=30, azim=30)

# Adding annotations for better readability
for i in range(len(total_runs)):
    ax.text(total_runs[i], perturbation_probabilities[i], collisions[i], '%d' % collisions[i], size=8, zorder=1, color='black')

plt.show()

